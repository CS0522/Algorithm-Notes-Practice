<!-- Authorized by Frank -->
- [要点总结](#要点总结)
  - [3](#3)
    - [图形输出 (P89)](#图形输出-p89)
    - [日期差 (P91)](#日期差-p91)
    - [进制转换 (P93)](#进制转换-p93)
  - [4](#4)
    - [选择排序 (P99)](#选择排序-p99)
    - [插入排序 (P100)](#插入排序-p100)
    - [递归 (P112)](#递归-p112)
    - [全排列 (P115)](#全排列-p115)
    - [(未学) 回溯 (P117)](#未学-回溯-p117)
    - [贪心 (P118)](#贪心-p118)
    - [快速幂 (P134)](#快速幂-p134)
    - [双指针 (P137)](#双指针-p137)
    - [归并排序 (P139)](#归并排序-p139)
    - [快速排序 (P142)](#快速排序-p142)
    - [随机选择算法 (P149)](#随机选择算法-p149)
  - [5](#5)
    - [最大公约数、最小公倍数](#最大公约数最小公倍数)
    - [素数判断 (P160)](#素数判断-p160)
    - [素数获取 (P162)](#素数获取-p162)
  - [6](#6)
    - [STL](#stl)
  - [7](#7)
    - [静态链表 (P260)](#静态链表-p260)
  - [8](#8)
    - [DFS (P269)](#dfs-p269)
    - [BFS (P274)](#bfs-p274)
  - [9](#9)
    - [二叉树的递归定义 (P284)](#二叉树的递归定义-p284)
    - [二叉树节点的插入 (P286)](#二叉树节点的插入-p286)
    - [时刻要注意判断左、右子树的判空](#时刻要注意判断左右子树的判空)
    - [给定遍历序列重建二叉树 (P294)](#给定遍历序列重建二叉树-p294)
    - [带权值的普通树的 DFS (P307)](#带权值的普通树的-dfs-p307)
    - [二叉查找树的插入 (P311)](#二叉查找树的插入-p311)
    - [二叉查找树的删除 (P313)](#二叉查找树的删除-p313)
    - [二叉查找树](#二叉查找树)
    - [AVL平衡二叉树的插入 (P321)](#avl平衡二叉树的插入-p321)
    - [并查集 (P328)](#并查集-p328)
    - [并查集的查找 (P329)](#并查集的查找-p329)
    - [并查集的路径压缩 (P330)](#并查集的路径压缩-p330)
    - [并查集例子 (P332)](#并查集例子-p332)
    - [堆 (P335)](#堆-p335)
    - [哈夫曼树 (P342)](#哈夫曼树-p342)

# 要点总结

## 3
### 图形输出 (P89)
* 通过行数和列数的规律，进行输出
* 定义一个二维数组，通过规律填充，然后输出二维数组
* eg: [3_B1036.cpp](./3_B1036.cpp)

### 日期差 (P91)
* 思路: 小日期不断增加，直到等于大日期
* 定义一个二维数组 `month[13][2]`
  * 第一维表示 12 个月份
  * 第二维为 0 表示平年天数，为 1 表示闰年天数

### 进制转换 (P93)
* 需要通过 10 进制中转


## 4
### 选择排序 (P99)

### 插入排序 (P100)

### 递归 (P112)
* 递归边界、递归式

### 全排列 (P115)
* 用 hashTable[index] 记录当前 index 是否已经加入到排列中
* eg: [4_FullPermutation.cpp](./4_FullPermutation.cpp)

### <font color="red">(未学) 回溯 (P117)</font>

### 贪心 (P118)
* 考虑当前状态下的局部最优策略
* eg: [4_B1023.cpp](./4_B1023.cpp)

### 快速幂 (P134)
* 定理:
  * b 为奇数，a<sup>b</sup> = a * a<sup>b-1</sup>
  * b 为偶数，a<sup>b</sup> = a<sup>b/2</sup> * a<sup>b/2</sup>
* eg: [4_FastPower.cpp](./4_FastPower.cpp)

### 双指针 (P137)
* 头、尾分别设置指针，然后向中间靠近，直到头指针 > 尾指针

### 归并排序 (P139)
* eg: [4_MergeSort.cpp](./4_MergeSort.cpp)

### 快速排序 (P142)
* eg: [4_QuickSort.cpp](./4_QuickSort.cpp)

### 随机选择算法 (P149)
* eg: [4_RandSelect.cpp](./4_RandSelect.cpp)


## 5
### 最大公约数、最小公倍数
* 辗转相除法: gcd(a, b) = gcd(b, a % b)，递归实现

### 素数判断 (P160)
* for 循环的范围 `[2 ~ sqrt(n)]`

### 素数获取 (P162)
* Eratosthenes 筛法
* 筛选掉所有倍数
* 设置辅助数组，记录某个数是否被筛选
* eg: [5_Eratosthenes.cpp](./5_Eratosthenes.cpp)


## 6
### STL
* [6_STL.md](./6_STL.md)


## 7
### 静态链表 (P260)
* 定义静态链表的节点时，通常除了数据域和指针域外，还会设置一个节点性质的标记
  ```cpp
  struct Node {
      int data;
      int next;
      // 节点某一个性质，根据题目而不同
      bool isInList;
  };
  ```
* 记得要初始化！
* 可能需要把有效节点全部移至数组左端
* eg: [7_A1032.cpp](./7_A1032.cpp), [7_A1052.cpp](./7_A1052.cpp)


## 8
### DFS (P269)
* 通过递归 (也就是栈) 可以很好地实现 DFS
* 注意 "死胡同" 和 "岔道口"，也就是递归的 `边界条件` 和 `递归表达式`
* "剪枝"，可以减少时间复杂度
* eg: [8_DFS.cpp](./8_DFS.cpp)

### BFS (P274)
* 通过队列，while 循环迭代进行实现
  ```cpp
  void BFS(...) 
  {
      queue<T> q;
      q.push(s);
      while (!q.empty())
      {
          ...
      }
  }
  ```
* 要点
  * 全局定义一些变量
  * 定义结构体(类)
  * 可能需要在结构体(类)中设置一些具有标记属性的性质
  * 访问的条件判断
* eg: [8_BFS_1.cpp](./8_BFS_1.cpp), [8_BFS_2.cpp](./8_BFS_2.cpp)


## 9
### 二叉树的递归定义 (P284)
* 要么没有根节点，是空树
* 要么由根节点、左子树、右子树组成，且左右子树都是二叉树

### 二叉树节点的插入 (P286)
* 二叉树节点的插入位置，就是 查找失败的位置
* 根据题目二叉树的性质，从左右子树中的一棵进行递归，最后到达空树的位置

### <font color="red">时刻要注意判断左、右子树的判空</font>

### 给定遍历序列重建二叉树 (P294)
* 必须得有中序遍历序列
* 中序遍历 + { 先序遍历 | 后序遍历 | 层序遍历 }
* 模板 (中序 + 先序)
* eg: [9_重建二叉树模板.cpp](./9_重建二叉树模板.cpp), [9_A1020.cpp](./9_A1020.cpp)

### 带权值的普通树的 DFS (P307)
* eg: [9_A1053.cpp](./9_A1053.cpp)
* 该题注意点
  * 普通树，用 vector 存子树的 index
  * 最后按权值的大小输出，可以在读入某节点的子树下标后，对 vector 进行 sort，这样可以优先访问大权值
  * 用 vector 保存 path 时，注意 push_back() 后别忘了 pop_back()

### 二叉查找树的插入 (P311)
* 插入某个值，如果这个值查找失败，则查找失败的地方就是这个节点的插入位置
* eg: [9_BST模板.cpp](./9_BST模板.cpp)

### 二叉查找树的删除 (P313)
* 递归思想
* 对于某个节点N，用其前驱(后继)节点P去替换节点N，然后转化为去左子树(右子树)中去删除节点P，然后一直递归，直到递归到一个叶子节点，直接删除
* eg: [9_BST模板.cpp](./9_BST模板.cpp)

### 二叉查找树
* eg: [9_A1043.cpp](./9_A1043.cpp)
  
### AVL平衡二叉树的插入 (P321)
* 注意要理解 LL、LR、RR、RL 四种情况，搞清楚左旋、右旋
* 作题之前最好画个图
* 插入情况汇总 (P326)

  | 树形 | 判定条件 | 调整方法 |
  |:---:|:-------:|:------- |
  | LL | BF(root)=2, BF(root->lchild)=1 | 对 root 右旋 |
  | LR | BF(root)=2, BF(root->lchild)=-1 | 对 root->lchild 左旋，再对 root 右旋 |
  | RR | BF(root)=2, BF(root->rchild)=-1 | 对 root 左旋 |
  | RL | BF(root)=2, BF(root->rchild)=1 | 对 root->rchild 右旋，在对 root 左旋 |

### 并查集 (P328)
* 合并、查找、集合
* 合并两个集合、判断两个元素是否在同一个集合

### 并查集的查找 (P329)
* 迭代或者递归，寻找所属集合的根节点

### 并查集的路径压缩 (P330)
* 使原本路径上的节点的父节点都是 集合的根节点

### 并查集例子 (P332)
* eg: [9_UnionSet.cpp](./9_UnionSet.cpp)

### 堆 (P335)
* 大根堆、小根堆
* 完全二叉树
* 数组存储
* eg: [9_Heap模板.cpp](./9_Heap模板.cpp)


### 哈夫曼树 (P342)
* 带权路径长度最小 (叶子节点的带权路径长度的和)
* 构建思想
  * 反复选择权值最小的两个元素，不断合并，最后只剩下一个元素
  * 想法是参照下面的模板，设置 priority_queue 的类型为 `Node*`，重写 `greater` 函数
* eg: [9_MinWeightPathLen.cpp](./9_MinWeightPathLen.cpp)
* 哈夫曼编码
  * 针对一个确定的字符串
  * 将字符串中每个字符出现的频率，作为节点的权值，构造哈夫曼树
  * 二叉树左孩子为 0, 右孩子为 1,进行编码 